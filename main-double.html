<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Domino ¬∑ Classic</title>

<style>
  :root{
    --accent:#e6a8ff;
    --accent2:#ffda8b;
    --tile:#fffaf5;
    --tile-edge:#e2c0ff;
    --tile-shadow:rgba(0,0,0,.25);
    --seat-fs:14px;
  }

  *{ box-sizing:border-box; }
  html, body{ height:100%; margin:0; padding:0; }

  body{
    font:500 16px Inter,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif;
    color:#fdf4ff;
    background:#3b281b;
    padding:20px;
    height:100vh;
    display:flex;
    justify-content:center;
    align-items:center;
  }

  /* ===== STAGE ===== */
  #stage{
    background:#2e2130;
    border-radius:20px;
    padding:20px;
    max-width:1200px;
    width:100%;
    height:100%;
    display:flex;
    flex-direction:column;
    align-items:center;
    box-shadow:0 0 20px rgba(0,0,0,.5);
  }
  h1{ margin:8px 0 6px; font-size:24px; font-weight:900; color:#f2d39a; }

  /* ===== MENU ===== */
  .menu{
    position:absolute;
    inset:0;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    gap:14px;
    padding:30px;
    z-index:100000;
    background:rgba(0,0,0,.8);
  }
  /* üî• —Å–∫—Ä—ã—Ç–∏–µ –º–µ–Ω—é –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ */
    /* üî• —Å–∫—Ä—ã—Ç–∏–µ –º–µ–Ω—é –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ */
  .menu.hidden {
    display:none !important;
    visibility:hidden !important;
    opacity:0 !important;
    pointer-events:none !important;
  }

  .menu label{ color:#f2d39a; font-weight:800; }
  .menu input{
    padding:8px 12px; width:220px; border-radius:8px; border:2px solid #8c5c2f;
    background:#fff6e7; color:#2b1a10; margin-top:4px;
  }
  .menu button{
    padding:10px 16px; border-radius:10px; border:2px solid #7a5525;
    font-weight:900; cursor:pointer; background:linear-gradient(#f1c97a,#e7b85f); color:#2b1a10;
  }
  /* –∏–º–µ–Ω–∞ –≤ —Å—Ç–æ–ª–±–∏–∫ */
  #nameInputs{ display:flex; flex-direction:column; gap:8px; width:260px; align-items:stretch; }
  .name-row{ display:flex; flex-direction:column; gap:4px; }
  .name-row label{ color:#f2d39a; font-weight:800; font-size:14px; }
  .name-row input{ width:100%; }

  /* ===== HUD ===== */
  .topbar{ width:100%; display:flex; align-items:center; justify-content:space-between; gap:10px; padding:10px 20px; }
  .players{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .player{ padding:6px 12px; border-radius:14px; background:rgba(230,168,255,.15); font-size:12px; }
  .player.active{ background:#f2c56a; color:#2b1a10; font-weight:900; box-shadow:0 0 14px #f2c56a; }
  .controls{ display:flex; gap:8px; }
  .btn{ padding:8px 14px; border-radius:10px; border:2px solid #7a5525; background:linear-gradient(#f1c97a,#e7b85f); color:#2c1a32; font-weight:800; }
  .btn:disabled{ opacity:.6; cursor:not-allowed; }
  #turnInfo{ margin:4px 0 6px; color:#ffda8b; font-weight:800; }

  /* ===== BOARD ===== */
  .board{
    position:relative; width:100%; flex:1; margin:20px 0; border-radius:16px; background:#1f1521;
    box-shadow:0 8px 24px rgba(0,0,0,.35), inset 0 0 18px rgba(0,0,0,.35);
    overflow:hidden; cursor:grab;
  }
  .board.grabbing{ cursor:grabbing; }
  .chain{ position:relative; width:100%; height:100%; }
  #chainZoom{ position:absolute; inset:0; transform-origin:0 0; }

  /* ===== TILES ===== */
  .tile{
    width:200px; height:70px;
    background:linear-gradient(#fffdf8,#fff6e7);
    border:2px solid #e7dbc9; border-radius:12px;
    display:grid; grid-template-columns:1fr 1fr; position:absolute;
    box-shadow:0 2px 6px rgba(0,0,0,.35), inset 0 0 0 2px #e0d3bd;
    overflow:hidden; user-select:none; -webkit-user-drag:element; transition:transform .12s;
  }
  .tile:hover{ transform:scale(1.04); }
  .tile .half{ display:flex; align-items:center; justify-content:center; padding:0 8px; overflow:visible; min-width:0; position:relative; }
  .tile .half:first-child{ border-right:2px solid #d8c8aa; }
  .tile.vert{ width:70px; height:200px; grid-template-columns:1fr; grid-template-rows:1fr 1fr; }
  .tile.vert .half:first-child{ border-right:none; border-bottom:2px solid #d8c8aa; }
.tile b {
  display:block;
  font-weight:900;
  color:#1c1712;
  white-space:nowrap;      /* –æ–¥–Ω–∞ —Å—Ç—Ä–æ–∫–∞ */
  overflow:hidden;
  text-align:center;
  line-height:1.1;
}
.tile .half img {
  max-width:90%;
  max-height:90%;
  object-fit:contain;
  margin:auto;
  display:block;
  padding:4px; /* –º–æ–∂–Ω–æ –ø–æ–¥–æ–≥–Ω–∞—Ç—å –æ—Ç–¥–µ–ª—å–Ω–æ */
}
/* ===== –ò–ó–ú–ï–ù–ï–ù–ò–ï #2: –°—Ç–∏–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¢–û–õ–¨–ö–û –¥–ª—è –ø—Ä–µ–≤—å—é ===== */
#tilePreview .half img {
  width: 250px;
  height: 250px;
  object-fit: contain;
  display: block;
}

  .tile.hand{ transform:scale(.65); transform-origin:left center; cursor:grab; filter:drop-shadow(0 1px 1px rgba(0,0,0,.25)); }
  .tile.hand *{ pointer-events:none; }

  /* ===== PREVIEW ===== */
  #tilePreview .tile{ width:680px!important; height:260px!important; }
 #tilePreview .tile b {
  font-size: 40px;
  font-weight: 900;
  color: #1c1712;
  text-align: center;
  line-height: 1.2;
  white-space: normal;    /* –ø–µ—Ä–µ–Ω–æ—Å */
  word-break: break-word; /* –ø–µ—Ä–µ–Ω–æ—Å –ø–æ —Å–ª–æ–≤–∞–º */
  overflow: auto;         /* —Å–∫—Ä–æ–ª–ª –µ—Å–ª–∏ –Ω–µ –≤–ª–µ–∑–ª–æ */
  max-height: 100%;
  padding: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
}


#tilePreview .half {
  display:flex;
  justify-content:center;
  align-items:center;
}

  /* ===== HAND ===== */
  .hands{ width:100%; display:flex; flex-direction:column; gap:10px; padding:10px 0 20px; }
  .hand-header{ width:100%; text-align:center; font-weight:900; color:#e9d2a2; }
  .tray{ width:100%; height:60px; display:flex; gap:8px; align-items:center; overflow-x:auto; padding:8px 10px; border:2px solid #8c5c2f; background:#5a3b21; border-radius:12px; }
  .tray>.tile{ position:static; }

  /* ===== DROP ZONES ===== */
  .dz{ position:absolute; width:38px; height:38px; border:2px dashed #b68a3e; border-radius:10px; display:none; background:rgba(255,215,120,.08); }
  .dz.active{ display:block; background:rgba(255,215,120,.28); box-shadow:0 0 16px rgba(255,215,120,.7); }
  .dz::after{ content:attr(data-dir); font-size:11px; color:#2c1a32; font-weight:900; background:#f2c56a; padding:2px 6px; border-radius:8px; position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); }

  /* ===== WIN OVERLAY ===== */
  .final-overlay{ position:absolute; inset:0; background:rgba(0,0,0,0.7); display:none; align-items:center; justify-content:center; z-index:100000; }
  .final-message{ font-size:42px; font-weight:900; color:#ffe97f; }
</style>
</head>
<body>

<div id="stage">
  <h1 id="title">Domino ¬∑ Classic</h1>

  <div id="menu" class="menu">
    <label>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–≥—Ä–æ–∫–æ–≤:
      <input type="number" id="playerCount" min="2" max="4" value="2">
    </label>
    <div id="nameInputs"></div>
    <button id="startBtn" type="button">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
  </div>

  <div class="topbar">
    <div id="playersBar" class="players"></div>
    <div class="controls">
      <button id="drawBtn" class="btn">–í–∑—è—Ç—å</button>
      <button id="skipBtn" class="btn">–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å</button>
      <button id="restartBtn" class="btn">–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å</button>
    </div>
  </div>
  <div id="turnInfo"></div>

  <div class="board" id="board">
    <div class="chain" id="chain">
      <div id="chainZoom"></div>
    </div>
  </div>

  <div class="hands">
    <div id="handHeader" class="hand-header"></div>
    <div id="tray" class="tray"></div>
  </div>

  <div id="finalOverlay" class="final-overlay">
    <div class="final-message">üéâ –ü–æ–±–µ–¥–∏—Ç–µ–ª—å: <span id="winnerName"></span> üéâ</div>
  </div>
</div>

<div id="tilePreview"
     style="position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:999999; background:rgba(0,0,0,.6)">
  <div id="tilePreviewInner"></div>
</div>
<canvas id="fireworksCanvas" style="position:fixed; inset:0; z-index:1000000; pointer-events:none; display:none;"></canvas>
<audio id="winSound" src="win.mp3" preload="auto"></audio>
<audio id="sDraw" src="draw.mp3" preload="auto"></audio>
<audio id="sPick" src="pick.mp3" preload="auto"></audio>
<audio id="sPlace" src="place.mp3" preload="auto"></audio>
<audio id="sClick" src="click.mp3" preload="auto"></audio>
<script>
/* ===========================================================================================
   Utils & State
=========================================================================================== */
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function uid(){ return Math.random().toString(36).slice(2,9); }
function br(){ return { w:chainEl.clientWidth, h:chainEl.clientHeight }; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function getQueryData(){
  const raw=new URLSearchParams(location.search).get('data');
  if(!raw) return null;
  try{ return JSON.parse(decodeURIComponent(raw)); }
  catch(e){ return null; }
}

// üî• —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –ø—Ä–æ–∏–≥—Ä—ã–≤–∞—Ç–µ–ª—å –∑–≤—É–∫–æ–≤
function playSound(id) {
  const el = document.getElementById(id);
  if (el) {
    el.currentTime = 0;
    el.play().catch(()=>{});
  }
}

/* constants */
const TILE_W=200, TILE_H=70, VERT_W=70, VERT_H=200, GAP=4, DZ=38;

/* DOM refs */
const menuEl=document.getElementById('menu');
const nameInputsEl=document.getElementById('nameInputs');
const playerCountEl=document.getElementById('playerCount');
const startBtn=document.getElementById('startBtn');

const playersBarEl=document.getElementById('playersBar');
const boardEl=document.getElementById('board');
const chainEl=document.getElementById('chain');
const chainZoom=document.getElementById('chainZoom');

const handHeader=document.getElementById('handHeader');
const trayEl=document.getElementById('tray');

const drawBtn=document.getElementById('drawBtn');
const skipBtn=document.getElementById('skipBtn');
const restartBtn=document.getElementById('restartBtn');
const turnInfo=document.getElementById('turnInfo');

const previewWrap=document.getElementById('tilePreview');
const previewInner=document.getElementById('tilePreviewInner');

/* Game state */
let playerNames=[], hands={}, deck=[], currentPlayer=0, passes={};
let openLeft=null, openRight=null, endLeft=null, endRight=null, dragging=null;

/* ===========================================================================================
   Pan & Zoom
=========================================================================================== */
let scale=1, panX=0, panY=0, isPanning=false, startPanX=0, startPanY=0;
function updateTransform(){ chainZoom.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`; }

boardEl.addEventListener('mousedown', e=>{
  if(e.button!==0 || e.target.closest('.dz, .tile')) return;
  e.preventDefault();
  isPanning=true;
  startPanX=e.clientX - panX;
  startPanY=e.clientY - panY;
  boardEl.classList.add('grabbing');
});
window.addEventListener('mousemove', e=>{
  if(!isPanning) return;
  e.preventDefault();
  panX = e.clientX - startPanX;
  panY = e.clientY - startPanY;
  updateTransform();
});
window.addEventListener('mouseup', ()=>{
  if(isPanning){ isPanning=false; boardEl.classList.remove('grabbing'); }
});
boardEl.addEventListener('wheel', e=>{
  e.preventDefault();
  const rect=boardEl.getBoundingClientRect();
  const mouseX=e.clientX - rect.left;
  const mouseY=e.clientY - rect.top;
  const newScale = clamp(scale * (1 - e.deltaY * 0.001), 0.2, 2.5);
  panX = mouseX - (mouseX - panX) * (newScale / scale);
  panY = mouseY - (mouseY - panY) * (newScale / scale);
  scale = newScale;
  updateTransform();
});

/* ===========================================================================================
   Menu inputs (players)
=========================================================================================== */
function renderNameInputs(){
  nameInputsEl.innerHTML='';
  const c=parseInt(playerCountEl.value,10)||2;
  for(let i=0;i<c;i++){
    const row=document.createElement('div');
    row.className='name-row';
    const lab=document.createElement('label');
    lab.textContent='–ò–º—è –∏–≥—Ä–æ–∫–∞ '+(i+1);
    const inp=document.createElement('input');
    inp.placeholder='–ò–º—è –∏–≥—Ä–æ–∫–∞ '+(i+1);
    inp.id='pname'+i;
    row.appendChild(lab);
    row.appendChild(inp);
    nameInputsEl.appendChild(row);
  }
}
playerCountEl.addEventListener('input',renderNameInputs);
renderNameInputs();

/* ===========================================================================================
   Big Preview
=========================================================================================== */
function fitPreviewText(wordEl, container) {
  if (!wordEl) return null;

  wordEl.style.lineHeight = "1.1";
  wordEl.style.whiteSpace = "nowrap"; // –ø—Ä–æ–±—É–µ–º —Å–Ω–∞—á–∞–ª–∞ –≤ –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É
  let best = 20;

  for (let s = 150; s >= 20; s--) {
    wordEl.style.fontSize = s + "px";
    const fits = wordEl.scrollWidth <= container.clientWidth - 8 &&
                 wordEl.scrollHeight <= container.clientHeight - 8;
    if (fits) {
      best = s; // –Ω–∞—à–ª–∏ –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –ø–æ–¥—Ö–æ–¥—è—â–∏–π —Ä–∞–∑–º–µ—Ä
    }
  }

  // –ø—Ä–æ–≤–µ—Ä–∫–∞: –µ—Å–ª–∏ –¥–∞–∂–µ –Ω–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–º (20px) —Ç–µ–∫—Å—Ç –Ω–µ –≤–ª–µ–∑
  wordEl.style.fontSize = best + "px";
  const stillTooBig = wordEl.scrollWidth > container.clientWidth - 8;

  if (stillTooBig) {
    // –≤–∫–ª—é—á–∞–µ–º –ø–µ—Ä–µ–Ω–æ—Å
    wordEl.style.whiteSpace = "normal";
    wordEl.style.wordBreak = "break-word";
  }

  return best;
}

function showPreview(a, b){
  previewInner.innerHTML = "";
  const big = document.createElement("div");
  big.className = "tile";
  big.style.position = "static";
  big.style.width = "680px"; 
  big.style.height = "260px";
  big.innerHTML = '<div class="half"></div><div class="half"></div>';
  previewInner.appendChild(big);

  const halfL = big.querySelector(".half:first-child");
  const halfR = big.querySelector(".half:last-child");
  const isImg = v=>/^https?:\/\/.+\.(png|jpg|jpeg|gif|svg|webp)$/i.test(v);

 function renderHalf(container, value){
  container.innerHTML="";
  if(isImg(value)){ 
    const img=document.createElement('img'); 
    img.src=value; 
    container.appendChild(img); 
  } else {
    const textEl=document.createElement('b'); 
    textEl.textContent=value; 
    textEl.style.fontSize = "40px"; 
    textEl.style.wordBreak = "break-word"; 
    textEl.style.whiteSpace = "normal"; 
    textEl.style.overflow = "auto"; 
    textEl.style.display = "flex";
    textEl.style.alignItems = "center";
    textEl.style.justifyContent = "center";
    container.appendChild(textEl); 
  }
}


  renderHalf(halfL, a);
  renderHalf(halfR, b);

  previewWrap.style.display='flex';
}

function hidePreview(){ previewWrap.style.display='none'; }
previewWrap.addEventListener('click',hidePreview);
addEventListener('keydown',e=>{ if(e.key==='Escape') hidePreview(); });

/* ===========================================================================================
   Tile factory (DOM)
=========================================================================================== */
function createTileEl(a,b,opts={}){
  const role=opts.role||'chain';
  const orient=opts.orient||'h';
  const el=document.createElement('div');
  el.className='tile '+(orient==='v'?'vert ':'')+(role==='hand'?'hand':'');
  el.style.left=(opts.left||0)+'px';
  el.style.top=(opts.top||0)+'px';
  el.innerHTML='<div class="half"><b></b></div><div class="half"><b></b></div>';

  const halves=el.getElementsByClassName('half');
function fitToHalf(node, container) {
  if (!node) return 12;

  let best = 12;
  node.style.whiteSpace = "nowrap";  // –≤—Å–µ–≥–¥–∞ –≤ –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É
  node.style.overflow = "hidden";
  node.style.textAlign = "center";

  // —É–º–µ–Ω—å—à–∞–µ–º —Ä–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞ –¥–æ —Ç–µ—Ö –ø–æ—Ä, –ø–æ–∫–∞ –í–ï–°–¨ —Ç–µ–∫—Å—Ç –Ω–µ –≤–ª–µ–∑–µ—Ç
  for (let s = 40; s >= 8; s--) {
    node.style.fontSize = s + "px";
    const fits =
      node.scrollWidth <= container.clientWidth - 4 &&
      node.scrollHeight <= container.clientHeight - 4;
    if (fits) {
      best = s;
      break;
    }
  }
  return best;
}


  const leftEl = halves[0].firstElementChild;
  const rightEl = halves[1].firstElementChild;
  const isImg=v=>/^https?:\/\/.+\.(png|jpg|jpeg|gif|svg|webp)$/i.test(v);

  function renderHalf(containerEl, value){
    containerEl.innerHTML="";
    if(isImg(value)){
      const img=document.createElement('img'); img.src=value; containerEl.appendChild(img);
      return null;
    }else{
      const b=document.createElement('b'); b.textContent=value; containerEl.appendChild(b); return b;
    }
  }

  const dispA = opts.displayA ?? a;
  const dispB = opts.displayB ?? b;

  const leftNode  = renderHalf(halves[0], dispA);
  const rightNode = renderHalf(halves[1], dispB);

  const leftSize  = leftNode  ? fitToHalf(leftNode,  halves[0]) : 12;
  const rightSize = rightNode ? fitToHalf(rightNode, halves[1]) : 12;
  const finalSize = Math.min(leftSize, rightSize);

  if(role === 'hand'){
    if(leftNode)  leftNode.style.fontSize  = (finalSize * 1.2) + "px";
    if(rightNode) rightNode.style.fontSize = (finalSize * 1.2) + "px";
  } else {
    if(leftNode)  leftNode.style.fontSize  = finalSize + "px";
    if(rightNode) rightNode.style.fontSize = finalSize + "px";
  }

  el.addEventListener('click',()=>showPreview(dispA,dispB));

  if(role==='hand'){
    el.draggable=true;
    el.addEventListener('dragstart',e=>{
      dragging={
        a:opts.aKey ?? a,
        b:opts.bKey ?? b,
        displayA: dispA,
        displayB: dispB,
        owner:opts.owner,
        uid:opts.uid
      };
      e.dataTransfer.setData('text/plain','domino');
      hidePreview();
      renderDirectionalZones();
       playSound("sPick"); 
    });
    
    el.addEventListener('dragend',()=>{
      dragging=null; clearZones();
    });
  }

  return el;
}

/* ===========================================================================================
   Collisions
=========================================================================================== */
function rectOf(o,x,y){ return { x, y, w:(o==='v'?VERT_W:TILE_W), h:(o==='v'?VERT_H:TILE_H) }; }
function intersects(r1,r2){ return !(r2.x>=r1.x+r1.w || r2.x+r2.w<=r1.x || r2.y>=r1.y+r1.h || r2.y+r2.h<=r1.y); }
function collidesWithExisting(r){
  for(const t of chainZoom.querySelectorAll('.tile:not(.hand)')){
    const w=t.classList.contains('vert')?VERT_W:TILE_W;
    const h=t.classList.contains('vert')?VERT_H:TILE_H;
    const r2={ x:parseInt(t.style.left||0), y:parseInt(t.style.top||0), w, h };
    if(intersects(r,r2)) return true;
  }
  return false;
}

/* ===========================================================================================
   Ends & positioning
=========================================================================================== */
function getSeam(end){
  if(end.orient==='h'){
    return end.dir===1
      ? {x:end.x + TILE_W,     y:end.y + TILE_H/2}
      : {x:end.x,              y:end.y + TILE_H/2};
  } else {
    return end.dir===1
      ? {x:end.x + VERT_W/2,   y:end.y + VERT_H}
      : {x:end.x + VERT_W/2,   y:end.y};
  }
}
function getNextPos(end, choice){
  let x,y,orient,nextDir;
  if(end.orient==='h'){
    const seamX = end.dir===1 ? end.x + TILE_W : end.x;
    switch(choice){
      case 'right': x=seamX + GAP;           y=end.y;                 orient='h'; nextDir= 1; break;
      case 'left':  x=seamX - TILE_W - GAP;  y=end.y;                 orient='h'; nextDir=-1; break;
      case 'down':  x=seamX - VERT_W/2;      y=end.y + TILE_H + GAP;  orient='v'; nextDir= 1; break;
      case 'up':    x=seamX - VERT_W/2;      y=end.y - VERT_H - GAP;  orient='v'; nextDir=-1; break;
    }
  } else {
    const seamY = end.dir===1 ? end.y + VERT_H : end.y;
    switch(choice){
      case 'up':    x=end.x;                 y=seamY - VERT_H - GAP;  orient='v'; nextDir=-1; break;
      case 'down':  x=end.x;                 y=seamY + GAP;           orient='v'; nextDir= 1; break;
      case 'right': x=end.x + VERT_W + GAP;  y=seamY - TILE_H/2;      orient='h'; nextDir= 1; break;
      case 'left':  x=end.x - TILE_W - GAP;  y=seamY - TILE_H/2;      orient='h'; nextDir=-1; break;
    }
  }
  return { x,y,orient,nextDir };
}
function applyPlaced(end,pos){ end.x=pos.x; end.y=pos.y; end.orient=pos.orient; end.dir=pos.nextDir; }

/* ===========================================================================================
   Drop zones
=========================================================================================== */
const DZ_SZ = DZ;
function clearZones(){ chainZoom.querySelectorAll('.dz').forEach(n=>n.remove()); }
function renderDirectionalZones(){
  clearZones();
  if(!dragging) return;
  const ends=[ {e:endLeft, id:'L', open:openLeft}, {e:endRight, id:'R', open:openRight} ];
for(const side of ends){
  if(!side.e || !side.e.el) continue;

  // –ø–æ–¥–¥–µ—Ä–∂–∫–∞ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã—Ö —Å—Ç–∞—Ä—Ç–æ–≤ A* / B*
const isA = v => typeof v==="string" && v.startsWith("A");
const isB = v => typeof v==="string" && v.startsWith("B");
const open = side.open;

let matches = false;
if(isA(open)){
  const expected = open.replace("A","B");
  matches = (dragging.a === expected && isA(dragging.b)) ||
            (dragging.b === expected && isA(dragging.a));
}
else if(isB(open)){
  const expected = open.replace("B","A");
  matches = (dragging.a === expected && isB(dragging.b)) ||
            (dragging.b === expected && isB(dragging.a));
}

if(!matches) continue;




  const seam = getSeam(side.e);

  const zones={
    up:    { left:seam.x - DZ_SZ/2, top:seam.y - DZ_SZ*2, dir:'‚Üë', k:'up'    },
    right: { left:seam.x + DZ_SZ,   top:seam.y - DZ_SZ/2, dir:'‚Üí', k:'right' },
    down:  { left:seam.x - DZ_SZ/2, top:seam.y + DZ_SZ,   dir:'‚Üì', k:'down'  },
    left:  { left:seam.x - DZ_SZ*2, top:seam.y - DZ_SZ/2, dir:'‚Üê', k:'left'  }
  };

  for(const k of Object.keys(zones)){
    const pos=getNextPos(side.e,k);
    if(!pos.orient) continue;
    const r=rectOf(pos.orient,pos.x,pos.y);
    if(collidesWithExisting(r)) continue;

    const z=document.createElement('div');
    z.className='dz active';
    z.style.left=zones[k].left+'px';
    z.style.top=zones[k].top+'px';
    z.dataset.dir=zones[k].dir;
    z.dataset.end=side.id;
    z.dataset.k=k;
    chainZoom.appendChild(z);
  }
}
} 

/* ===========================================================================================
   Rules / helpers
=========================================================================================== */
function desiredHalfFor(choice){ return (choice==='right' || choice==='down') ? 'a' : 'b'; }

function canPlaceTileAtEnd(tile, end, choice, endOpen){
  if(!end || !end.el) return false;
  const pos = getNextPos(end, choice);
  if(!pos.orient) return false;

  let a = tile.a, b = tile.b;

  // üëâ —Å–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–µ —Å—Ç–∞—Ä—Ç—ã
  if(endOpen==="A*" && (a.startsWith("A") || b.startsWith("A"))) {
    // –≤—Å—ë –æ–∫, –º–æ–∂–Ω–æ —Å—Ç—ã–∫–æ–≤–∞—Ç—å
  } else if(endOpen==="B*" && (a.startsWith("B") || b.startsWith("B"))) {
    // –≤—Å—ë –æ–∫
  } else {
 // –æ–±—ã—á–Ω–æ–µ –ø—Ä–∞–≤–∏–ª–æ: –¥–æ–ª–∂–Ω–æ —Å–æ–≤–ø–∞—Å—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ
// —Å—Ç—ã–∫ —Ç–æ–ª—å–∫–æ B ‚Üî A
const isA = v => typeof v==="string" && v.startsWith("A");
const isB = v => typeof v==="string" && v.startsWith("B");

if (isA(endOpen)) {
  // –∫–æ–Ω–µ—Ü –æ—Ç–∫—Ä—ã—Ç A ‚Üí —Å–æ–≤–ø–∞–¥–∞—Ç—å –¥–æ–ª–∂–µ–Ω –∏–º–µ–Ω–Ω–æ A –ø–ª–∏—Ç–∫–∏
  if (a !== endOpen && b !== endOpen) return false;
  // –∏ –≤—Ç–æ—Ä–∞—è –ø–æ–ª–æ–≤–∏–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å B
  const other = (a === endOpen) ? b : a;
  if (!isB(other)) return false;
}

if (isB(endOpen)) {
  // –∫–æ–Ω–µ—Ü –æ—Ç–∫—Ä—ã—Ç B ‚Üí —Å–æ–≤–ø–∞–¥–∞—Ç—å –¥–æ–ª–∂–µ–Ω –∏–º–µ–Ω–Ω–æ B –ø–ª–∏—Ç–∫–∏
  if (a !== endOpen && b !== endOpen) return false;
  // –∏ –≤—Ç–æ—Ä–∞—è –ø–æ–ª–æ–≤–∏–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å A
  const other = (a === endOpen) ? b : a;
  if (!isA(other)) return false;
}

const r = rectOf(pos.orient, pos.x, pos.y);
return !collidesWithExisting(r);
  }
}

function hasLegalMove(hand){
  const ends = [
    { e:endLeft, open:openLeft },
    { e:endRight, open:openRight }
  ];

  for(const t of hand){
    for(const side of ends){
      const endOpen = side.open;
      if(!endOpen) continue;

      // üî• –æ–±—ã—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞
      if (t.a === endOpen || t.b === endOpen) {
        return true;
      }
    }
  }
  return false;
}


/* üî• –¥–æ–±–∞–≤–ª—è–µ–º –∞–ª–∏–∞—Å, —á—Ç–æ–±—ã updateControls —Ä–∞–±–æ—Ç–∞–ª */
function hasPlayable(hand){
  return hasLegalMove(hand);
}
/* ===========================================================================================
   Placing / autorotate
=========================================================================================== */
function placeAt(whichEnd, tileData, choice) {
  const end = (whichEnd === 'left') ? endLeft : endRight;
  const pos = getNextPos(end, choice);
  const r   = rectOf(pos.orient, pos.x, pos.y);
  if (!pos.orient || collidesWithExisting(r)) return false;

  let a = tileData.a, b = tileData.b;
  let dispA = tileData.displayA, dispB = tileData.displayB;

  // üî• –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –ø–æ–≤–æ—Ä–æ—Ç: –µ—Å–ª–∏ –∫–æ–Ω–µ—Ü —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å b ‚Äî –º–µ–Ω—è–µ–º –º–µ—Å—Ç–∞–º–∏
  const endOpen = (whichEnd === 'left') ? openLeft : openRight;
  if (endOpen === b) {
    [a, b] = [b, a];
    [dispA, dispB] = [dispB, dispA];
  }

  const newTile = createTileEl(
    a, b,
    { orient: pos.orient, left: pos.x, top: pos.y, displayA: dispA, displayB: dispB }
  );
  chainZoom.appendChild(newTile);

  applyPlaced(end, pos);
  end.el = newTile;
  return true;
}



function tryPlace(target, data){
  if(!data || !target.classList.contains('dz')) return false;

  const isLeft = target.dataset.end==='L';
  const choice = target.dataset.k;
  const endOpen = isLeft ? openLeft : openRight;

  let newOpen = null;

  // –∫–æ–Ω–µ—Ü A ‚Üí –∏—â–µ–º B —Å —Ç–µ–º –∂–µ –∏–Ω–¥–µ–∫—Å–æ–º
  if(endOpen.startsWith("A")){
    const expected = endOpen.replace("A","B");
    if(data.a === expected) newOpen = data.b;
    else if(data.b === expected) newOpen = data.a;
    else return false;
  }
  // –∫–æ–Ω–µ—Ü B ‚Üí –∏—â–µ–º A —Å —Ç–µ–º –∂–µ –∏–Ω–¥–µ–∫—Å–æ–º
  else if(endOpen.startsWith("B")){
    const expected = endOpen.replace("B","A");
    if(data.a === expected) newOpen = data.b;
    else if(data.b === expected) newOpen = data.a;
    else return false;
  }

  if(placeAt(isLeft?'left':'right', data, choice)){
    if(isLeft) openLeft = newOpen; else openRight = newOpen;
    return true;
  }

  return false;
}



/* ===========================================================================================
   Fit chain
=========================================================================================== */
function fitChain(){
  const tiles=[...chainZoom.querySelectorAll('.tile:not(.hand)')];
  if(!tiles.length){ scale=1; panX=0; panY=0; updateTransform(); return; }
  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
  for(const t of tiles){
    const x=parseInt(t.style.left||0), y=parseInt(t.style.top||0);
    const w=t.classList.contains('vert')?VERT_W:TILE_W;
    const h=t.classList.contains('vert')?VERT_H:TILE_H;
    minX=Math.min(minX,x); minY=Math.min(minY,y);
    maxX=Math.max(maxX,x+w); maxY=Math.max(maxY,y+h);
  }
  const pad=20;
  const s=Math.min(1,(br().w-pad)/(maxX-minX),(br().h-pad)/(maxY-minY));
  scale=s;
  panX=(br().w - (maxX-minX)*s)/2 - minX*s;
  panY=(br().h - (maxY-minY)*s)/2 - minY*s;
  updateTransform();
}
addEventListener('resize', ()=>{ fitChain(); if(dragging) renderDirectionalZones(); });

/* ===========================================================================================
   UI: players & hand
=========================================================================================== */
function renderPlayersBar() {
  playersBarEl.innerHTML = '';
  for (let i = 0; i < playerNames.length; i++) {
    const el = document.createElement('div');
    el.className = 'player' + (i === currentPlayer ? ' active' : '');
    el.textContent = playerNames[i] || `–ò–≥—Ä–æ–∫ ${i+1}`;
    playersBarEl.appendChild(el);
  }
  playersBarEl.style.display = "flex"; // –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ –≤–∏–¥–Ω–æ
}

function renderHand(){
  handHeader.textContent = `${playerNames[currentPlayer]}: (${(hands[currentPlayer]||[]).length} –∫–æ—Å—Ç—è—à–µ–∫)`;
  trayEl.innerHTML='';
  for(const t of (hands[currentPlayer]||[])){
    const el=createTileEl(
      t.a, t.b,
      { role:'hand', owner:currentPlayer, uid:t.uid, orient:'h', draggable:true, displayA:t.displayA, displayB:t.displayB, aKey:t.a, bKey:t.b }
    );
    trayEl.appendChild(el);
  }
}

function updateControls(){
  [...playersBarEl.getElementsByClassName('player')]
    .forEach((n,idx)=>n.classList.toggle('active',idx===currentPlayer));

  turnInfo.textContent = `–•–æ–¥: ${playerNames[currentPlayer]}`;

  const currentHand = hands[currentPlayer] || [];
  
  // üî• –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: –ø—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ —Ç–æ–ª—å–∫–æ A/B, –Ω–æ –∏ –æ–±—ã—á–Ω—ã–µ —Å–ª–æ–≤–∞
  const playable = hasLegalMove(currentHand);

  if (playable) {
    drawBtn.disabled = true;
    skipBtn.disabled = true;
  } else {
    if (deck.length > 0) {
      drawBtn.disabled = false;   // –º–æ–∂–Ω–æ –≤–∑—è—Ç—å
      skipBtn.disabled = true;
    } else {
      drawBtn.disabled = true;
      skipBtn.disabled = false;   // –º–æ–∂–Ω–æ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å
    }
  }
}



/* ===========================================================================================
   Fireworks + Sound
=========================================================================================== */
const fwCanvas = document.getElementById('fireworksCanvas');
const fwCtx = fwCanvas.getContext('2d');
const winSound = document.getElementById('winSound');
let fwParticles = []; let fwRunning = false;
function resizeFW(){ fwCanvas.width = window.innerWidth; fwCanvas.height = window.innerHeight; }
window.addEventListener('resize', resizeFW); resizeFW();
function launchFirework(){
  const colors = ["#ff4d6d","#ffd93d","#00f5d4","#9d4edd","#f72585","#4cc9f0"];
  const x = Math.random() * fwCanvas.width; const y = Math.random() * fwCanvas.height/2;
  for(let i=0;i<100;i++){
    fwParticles.push({ x, y, angle: Math.random()*2*Math.PI, speed: Math.random()*5+2, life: 100, color: colors[Math.floor(Math.random()*colors.length)] });
  }
}
function updateFW(){
  fwCtx.clearRect(0,0,fwCanvas.width,fwCanvas.height);
  fwParticles.forEach(p=>{
    p.x += Math.cos(p.angle)*p.speed; p.y += Math.sin(p.angle)*p.speed; p.life -= 2;
    fwCtx.fillStyle = p.color; fwCtx.globalAlpha = Math.max(p.life/100,0);
    fwCtx.beginPath(); fwCtx.arc(p.x,p.y,2,0,Math.PI*2); fwCtx.fill();
  });
  fwParticles = fwParticles.filter(p=>p.life>0);
  if(fwRunning) requestAnimationFrame(updateFW);
}
function startFireworks(){
  fwCanvas.style.display="block"; fwRunning=true;
  if (winSound){ winSound.currentTime = 0; winSound.play().catch(()=>{}); }
  setInterval(launchFirework,600); updateFW();
}

/* ===========================================================================================
   Deck (from data) + default
=========================================================================================== */
function buildDeckFromData(d){
  const out = [];
  const A = (d && Array.isArray(d.listA)) ? d.listA : [];
  const B = (d && Array.isArray(d.listB)) ? d.listB : [];

 const m = Math.min(A.length, B.length);
for (let i = 0; i < m; i++){
  for (let j = 0; j < m; j++){
    if (i === j) continue;               // üî• –∏—Å–∫–ª—é—á–∞–µ–º –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –∏–Ω–¥–µ–∫—Å—ã
    out.push({
      a: "A"+i,                           // —Å–ø—Ä–∞–≤–∞ ‚Äî A[i]
      b: "B"+j,                           // —Å–ª–µ–≤–∞ ‚Äî B[j]
      displayA: B[j],                     // –°–õ–ï–í–ê –ø–æ–∫–∞–∑—ã–≤–∞–µ–º B
      displayB: A[i],                     // –°–ü–†–ê–í–ê –ø–æ–∫–∞–∑—ã–≤–∞–µ–º A
      uid: uid()
    });
  }
}


  return out;
}

function makeDefaultDeck(){
  const F=["–∫–æ—Ç","–ø—ë—Å","–ª—É–Ω–∞","—Å–æ–ª–Ω—Ü–µ","–∑–≤–µ–∑–¥–∞","–º–æ—Å—Ç","—Ä–µ–∫–∞","–¥–æ–º","–ª–µ—Å","–º–æ—Ä–µ","—Å–∞–º–æ–ª—ë—Ç"];
  const out=[];
  for(let i=0;i<F.length;i++){
    for(let j=i;j<F.length;j++){
      out.push({ a:i, b:j, displayA:F[i], displayB:F[j], uid:uid() });
    }
  }
  return out;
}

/* –æ—Ü–µ–Ω–∫–∞ –µ–¥–∏–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞ —à—Ä–∏—Ñ—Ç–∞ ‚Äî –ø–æ –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º—ã–º —Å–ª–æ–≤–∞–º/–∫–∞—Ä—Ç–∏–Ω–∫–∞–º (—Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç) */
function computeUniformSize(deck){
  const words=[];
  for(const t of deck){
    if(typeof t.displayA==='string' && !/^https?:\/\//i.test(t.displayA)) words.push(t.displayA);
    if(typeof t.displayB==='string' && !/^https?:\/\//i.test(t.displayB)) words.push(t.displayB);
  }
  if(!words.length) return;

  const meas=document.createElement('div');
  meas.style.cssText=`position:fixed;left:-9999px;top:-9999px;width:${TILE_W/2-24}px;white-space:nowrap;font-weight:900;font-family:Inter,system-ui,sans-serif;`;
  document.body.appendChild(meas);
  let min=30;
  for(const w of words){
    let s=30; meas.style.fontSize=s+'px'; meas.textContent=w;
    while(s>10 && meas.scrollWidth>meas.clientWidth){ s--; meas.style.fontSize=s+'px'; }
    min=Math.min(min,s);
  }
  document.body.removeChild(meas);
  // –µ—Å–ª–∏ —Ö–æ—á–µ—à—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å min –≥–¥–µ-—Ç–æ –≥–ª–æ–±–∞–ª—å–Ω–æ ‚Äî –º–æ–∂–Ω–æ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å
}

/* ===========================================================================================
   Game flow
=========================================================================================== */
function nextPlayer(){ currentPlayer=(currentPlayer+1)%playerNames.length; renderPlayersBar(); renderHand(); updateControls(); } document.getElementById("playersBar").style.display = "flex";
function everyonePassed(){ for(let i=0;i<playerNames.length;i++){ if(!passes[i]) return false; } return true; }
function endByWinner(i){
  document.getElementById('winnerName').textContent = playerNames[i];
  document.getElementById('finalOverlay').style.display = 'flex';
  startFireworks();
}
function endByPoints(){
  let best=Infinity, wi=0;
  for(let i=0;i<playerNames.length;i++){ const s=(hands[i]||[]).length; if(s<best){ best=s; wi=i; } }
  endByWinner(wi);
}

/* ===========================================================================================
   Start game
=========================================================================================== */
function startGame(){
  const n=Math.max(2,Math.min(4,parseInt(playerCountEl.value)||2));

  // names
  playerNames=[];
  for(let i=0;i<n;i++){
    playerNames.push((document.getElementById('pname'+i)?.value||'').trim()||('–ò–≥—Ä–æ–∫ '+(i+1)));
  }

  // deck ‚Äî —Å–Ω–∞—á–∞–ª–∞ –∏–∑ ?data=listA, –∏–Ω–∞—á–µ –¥–µ—Ñ–æ–ª—Ç
 // deck ‚Äî —Å–Ω–∞—á–∞–ª–∞ –∏–∑ ?data=listA, –∏–Ω–∞—á–µ –¥–µ—Ñ–æ–ª—Ç
const data = getQueryData() || {};
deck = buildDeckFromData(data);
if(!deck.length){ deck = makeDefaultDeck(); }
shuffle(deck);

// —à—Ä–∏—Ñ—Ç –ø–æ–¥ –≤—Å–µ —Å–ª–æ–≤–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
computeUniformSize(deck);

// —Å—Ç–∞—Ä—Ç–æ–≤–∞—è –Ω–∞ –ø–æ–ª–µ
chainZoom.innerHTML='';
const sx = Math.floor((br().w - TILE_W) / 2);
const sy = Math.floor((br().h - TILE_H) / 2);

// ‚ö°Ô∏è –°–Ω–∞—á–∞–ª–∞ –±–µ—Ä—ë–º —Å—Ç–∞—Ä—Ç–æ–≤—É—é –∫–æ—Å—Ç—è—à–∫—É –∏–∑ –∫–æ–ª–æ–¥—ã
let first = deck.shift();
if (!first) {
  console.error("Deck is empty before deal ‚Äî cannot start game");
  return; // –≤—ã—Ö–æ–¥–∏–º, –µ—Å–ª–∏ –≤–æ–æ–±—â–µ –Ω–µ—Ç –∫–æ–ª–æ–¥—ã
}

// reset hands/pass
hands = {}; passes = {}; currentPlayer = 0;
for (let i = 0; i < n; i++) { hands[i] = []; passes[i] = 0; }

// —Ç–µ–ø–µ—Ä—å —Ä–∞–∑–¥–∞—ë–º –ø–æ 7 –∫–æ—Å—Ç—è—à–µ–∫ –∏–∑ –æ—Å—Ç–∞—Ç–∫–∞ –∫–æ–ª–æ–¥—ã
for (let r = 0; r < 7; r++) {
  for (let i = 0; i < n; i++) {
    if (!deck.length) break;
    hands[i].push(deck.shift());
  }
}

// —Å–æ–∑–¥–∞—ë–º —ç–ª–µ–º–µ–Ω—Ç –∏ –∫–ª–∞–¥—ë–º –µ–≥–æ –≤ —Ü–µ–Ω—Ç—Ä
const startTile = createTileEl(first.a, first.b, {
  orient: 'h',
  left: sx,
  top: sy,
  displayA: first.displayA, // –°–ª–µ–≤–∞ B
  displayB: first.displayB  // –°–ø—Ä–∞–≤–∞ A
});
chainZoom.appendChild(startTile);

// —Ç–æ–ª—å–∫–æ —Ç–µ–ø–µ—Ä—å –≤—ã—Å—Ç–∞–≤–ª—è–µ–º –∫–æ–Ω—Ü—ã
openLeft  = first.b; // —Å–ª–µ–≤–∞ —Ç–µ–ø–µ—Ä—å –≤—Å–µ–≥–¥–∞ B*
openRight = first.a; // —Å–ø—Ä–∞–≤–∞ –≤—Å–µ–≥–¥–∞ A*
endLeft   = { x: sx, y: sy, orient: 'h', dir: -1, el: startTile };
endRight  = { x: sx, y: sy, orient: 'h', dir:  1, el: startTile };

 
   renderPlayersBar();
  renderHand();
  updateControls();
  fitChain();

  // --- –ñ–Å–°–¢–ö–û–ï —Å–∫—Ä—ã—Ç–∏–µ –º–µ–Ω—é ---
  menuEl.classList.add('hidden');
  menuEl.setAttribute('aria-hidden', 'true');
  menuEl.style.display = 'none';
  menuEl.style.visibility = 'hidden';
  menuEl.style.opacity = '0';
  menuEl.style.pointerEvents = 'none';
  // ----------------------------

  document.getElementById('title').textContent = 'Domino ¬∑ Classic';
}

/* ===========================================================================================
   Buttons & DnD
=========================================================================================== */
drawBtn.addEventListener('click', ()=>{
  const hand = hands[currentPlayer] || [];
  if (!deck.length) return;
  hand.push(deck.shift());
  hands[currentPlayer] = hand;
  renderHand();
  updateControls();
  playSound("sDraw"); // üî• –∑–≤—É–∫ ¬´–≤–∑—è–ª –∏–∑ –∫–æ–ª–æ–¥—ã¬ª
});

skipBtn.addEventListener('click', ()=>{
  passes[currentPlayer]=(passes[currentPlayer]||0)+1;
  if(everyonePassed()){ endByPoints(); return; }
  nextPlayer();
});

restartBtn.addEventListener('click', ()=>location.reload());

// ‚ú® —Ç–µ–ø–µ—Ä—å ¬´–ù–∞—á–∞—Ç—å¬ª –∏–≥—Ä–∞–µ—Ç –∑–≤—É–∫ —Å—Ä–∞–∑—É
startBtn.addEventListener('click', ()=>{
  playSound("sClick");  
  startGame();
});

// üî• –æ–±—â–∏–π –∑–≤—É–∫ –∫–ª–∏–∫–∞ –¥–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö UI-–∫–Ω–æ–ø–æ–∫
[restartBtn, skipBtn].forEach(btn=>{
  btn.addEventListener('click', ()=>playSound("sClick"));
});

addEventListener('dragover', e=>{ if(dragging) e.preventDefault(); });

addEventListener('drop', e=>{
  const t=e.target;
  if(!dragging) return;
  if(t && t.classList && t.classList.contains('dz')){
    e.preventDefault();
    const ok=tryPlace(t,dragging);
    if(ok){
      const arr=hands[dragging.owner]||[];
      hands[dragging.owner]=arr.filter(x=>x.uid!==dragging.uid);
      renderHand();
      playSound("sPlace"); // üî• –∑–≤—É–∫ ¬´–ø–æ—Å—Ç–∞–≤–∏–ª —Ñ–∏—à–∫—É¬ª
      if(hands[dragging.owner].length===0){
        endByWinner(dragging.owner);
        dragging=null; clearZones(); return;
      }
      passes[currentPlayer]=0;
      nextPlayer();
    }
    dragging=null;
    clearZones();
  }
});

addEventListener('mousemove', ()=>{ if(dragging) renderDirectionalZones(); });

/* Safety init */
(function(){
  if(document.readyState==='loading'){
    document.addEventListener('DOMContentLoaded', ()=>{ renderNameInputs(); });
  } else {
    renderNameInputs();
  }
})();
</script>
</body>
</html>
